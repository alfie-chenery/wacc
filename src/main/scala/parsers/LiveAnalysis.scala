package parsers

import parsers.Assembly.{ADD, ADDS, AND, B, BL, CMP, DAscii, DWord, EOR, LDR, LTORG, MOV, MULTS, Mnemonic, ORR, POP, PUSH, RSBS, Register, SMULL, STR, STRB, SUB, SUBS, ScratchReg, TempReg, asr, funcName, lsl, regShift, regVal}
import parsers.ControlFlowGraph.CFGNode

import scala.collection.immutable.{HashSet, ListMap}
import scala.collection.mutable
import scala.collection.mutable.ListBuffer

object LiveAnalysis {

  class LVACFGNode(override val id: Int,
                   override val instruction: Mnemonic,
                   var uses: mutable.Set[TempReg],
                   var defs: mutable.Set[TempReg],
                   succs: mutable.Set[Int]) extends CFGNode(id, instruction, succs)

  def tempReg(s: mutable.HashSet[Any]): mutable.HashSet[TempReg] = s.map {
    case regVal(r) => r
    case regShift(r, _, _) => r
    case asr(r, _) => r
    case lsl(r, _) => r
    case r => r
  }.filter(_.isInstanceOf[TempReg]).map(_.asInstanceOf[TempReg])

  /**
   * @param cfg : control flow graph, as generated by the ControlFlowGraph package
   * @return a mapping from temporary registers to scratch registers, optimised with graph colouring
   */
  def liveVariableAnalysis(cfg: ListBuffer[CFGNode]): mutable.Map[TempReg, ScratchReg] = {
    val nodes: ListBuffer[LVACFGNode] = cfg.map(c => new LVACFGNode(c.id, c.instruction, mutable.HashSet[TempReg](), mutable.HashSet[TempReg](), c.succs))

    // assign defs and uses for each node
    for (n <- nodes) {
      n.instruction match {
        case LDR(r, o2, _) =>
          n.defs = tempReg(mutable.HashSet(r))
          n.uses = tempReg(mutable.HashSet(o2))
        case STR(rd, rn) =>
          n.uses = tempReg(mutable.HashSet(rd, rn))
        case PUSH(r) =>
          n.uses = tempReg(mutable.HashSet(r))
        case POP(r) =>
          n.defs = tempReg(mutable.HashSet(r))
        case SUB(o1, o2, o3) =>
          n.defs = tempReg(mutable.HashSet(o1))
          n.uses = tempReg(mutable.HashSet(o2, o3))
        case ADD(o1, o2, o3) =>
          n.defs = tempReg(mutable.HashSet(o1))
          n.uses = tempReg(mutable.HashSet(o2, o3))
        case MOV(rd, o2, _) =>
          n.defs = tempReg(mutable.HashSet(rd))
          n.uses = tempReg(mutable.HashSet(o2))
        case CMP(r, o2) =>
          n.uses = tempReg(mutable.HashSet(r, o2))
        case STRB(rd, rn) =>
          n.uses = tempReg(mutable.HashSet(rd, rn))
        case AND(rd, rn, rm) =>
          n.defs = tempReg(mutable.HashSet(rd))
          n.uses = tempReg(mutable.HashSet(rn, rm))
        case ORR(rd, rn, rm) =>
          n.defs = tempReg(mutable.HashSet(rd))
          n.uses = tempReg(mutable.HashSet(rn, rm))
        case ADDS(rd, rn, rm) =>
          n.defs = tempReg(mutable.HashSet(rd))
          n.uses = tempReg(mutable.HashSet(rn, rm))
        case SUBS(rd, rn, rm) =>
          n.defs = tempReg(mutable.HashSet(rd))
          n.uses = tempReg(mutable.HashSet(rn, rm))
        case MULTS(rd, rn, rm) =>
          n.defs = tempReg(mutable.HashSet(rd))
          n.uses = tempReg(mutable.HashSet(rn, rm))
        case SMULL(rdLo, rdHi, rm, rs) =>
          n.defs = tempReg(mutable.HashSet(rdLo, rdHi))
          n.uses = tempReg(mutable.HashSet(rm, rs))
        case EOR(rd, o2, o3) =>
          n.defs = tempReg(mutable.HashSet(rd))
          n.uses = tempReg(mutable.HashSet(o2, o3))
        case RSBS(rd, o2, o3) =>
          n.defs = tempReg(mutable.HashSet(rd))
          n.uses = tempReg(mutable.HashSet(o2, o3))
        case _ =>
      }
    }

    // maps from node (instr.) index to set of livein/liveout regs
    val liveIn, liveOut: mutable.HashMap[Int, mutable.Set[TempReg]] = new mutable.HashMap[Int, mutable.Set[TempReg]]()

    for (n <- nodes) {
      liveIn(n.id) = mutable.Set[TempReg]()
      liveOut(n.id) = mutable.Set[TempReg]()
    }

    var prevLiveIn, prevLiveOut: mutable.HashMap[Int, mutable.Set[TempReg]] = mutable.HashMap()

    do {
      prevLiveIn = liveIn
      prevLiveOut = liveOut
      println(nodes.reverse)
      for (n <- nodes.reverse) {
        liveIn(n.id) = n.uses.union(liveOut(n.id).diff(n.defs))
        liveOut(n.id) = n.succs.foldLeft(mutable.Set[TempReg]())((a: mutable.Set[TempReg], i: Int) => liveIn(i).union(a))
      }
    } while (prevLiveIn != liveIn && prevLiveOut != liveOut)

    println("liveIn: ", liveIn)
    println("liveOut: ", liveOut)

    // Interference analysis:
    val interferes: mutable.Map[TempReg, mutable.Set[TempReg]] = mutable.HashMap[TempReg, mutable.Set[TempReg]]()
    for (t <- RegisterAllocator.allTempRegisters) {
      for (n <- nodes) {
        if (liveOut(n.id).contains(t)) {
          interferes(t) = liveOut(n.id)
        }
      }
    }

    println("interferes: ", interferes)
    val tempAllocation: mutable.Map[TempReg, ScratchReg] = graphColouring(interferes)
    println("tempAllocation: ", tempAllocation)

    tempAllocation
  }

  def graphColouring(interferes: mutable.Map[TempReg, mutable.Set[TempReg]]): mutable.Map[TempReg, ScratchReg] = {
    // Uses a greedy approximation algorithm that runs in linear time
    val tempAllocation: mutable.Map[TempReg, ScratchReg] = mutable.HashMap()
    val available: List[ScratchReg] = RegisterAllocator.allScratchRegisters
    for ((tempReg, adj) <- ListMap(interferes.toSeq.sortBy(_._2.size): _*)) { // uses sorted tempRegs by degree
      var i: Int = 0
      while (adj.exists(a => if (tempAllocation.contains(a)) tempAllocation(a) == available(i) else false)) {
        i += 1
      }
      tempAllocation(tempReg) = available(i)
      // todo: spillage..?
    }
    tempAllocation
  }
  // todo: refactor into separate control flow intermediate representation pass
  //  val stCFG: mutable.HashMap[String, Int] = new mutable.HashMap[String, Int]()
}